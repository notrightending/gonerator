// Code generated by gonerator. DO NOT EDIT.

package example

import (
	"encoding/json"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"strings"
)

func (h *MyApi) handlerProfile(w http.ResponseWriter, r *http.Request) {

	allowedMethods := strings.Split("GET,POST", ",")
	methodAllowed := false
	for _, m := range allowedMethods {
		if r.Method == strings.TrimSpace(m) {
			methodAllowed = true
			break
		}
	}
	if !methodAllowed {
		http.Error(w, "{\"error\": \"bad method\"}", http.StatusNotAcceptable)
		return
	}

	var params ProfileParams

	var queryParams url.Values
	if r.Method == "GET" {
		queryParams = r.URL.Query()
	} else {
		err := r.ParseForm()
		if err != nil {
			http.Error(w, "{\"error\": \""+err.Error()+"\"}", http.StatusBadRequest)
			return
		}
		queryParams = r.Form
	}

	params.Login = queryParams.Get("login")

	if params.Login == "" {
		http.Error(w, "{\"error\": \"login must be not empty\"}", http.StatusBadRequest)
		return
	}

	res, err := h.Profile(r.Context(), params)
	if err != nil {
		if apiErr, ok := err.(ApiError); ok {
			http.Error(w, "{\"error\": \""+apiErr.Error()+"\"}", apiErr.HTTPStatus)
		} else {
			http.Error(w, "{\"error\": \""+err.Error()+"\"}", http.StatusInternalServerError)
		}
		return
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"error":    "",
		"response": res,
	})
}

func (h *MyApi) handlerCreate(w http.ResponseWriter, r *http.Request) {

	authKey := os.Getenv("MY_API_KEY")
	if authKey == "" {
		http.Error(w, "{\"error\": \"Server configuration error: missing auth key\"}", http.StatusInternalServerError)
		return
	}
	if r.Header.Get("X-Auth") != authKey {
		http.Error(w, "{\"error\": \"unauthorized\"}", http.StatusForbidden)
		return
	}

	allowedMethods := strings.Split("POST", ",")
	methodAllowed := false
	for _, m := range allowedMethods {
		if r.Method == strings.TrimSpace(m) {
			methodAllowed = true
			break
		}
	}
	if !methodAllowed {
		http.Error(w, "{\"error\": \"bad method\"}", http.StatusNotAcceptable)
		return
	}

	var params CreateParams

	var queryParams url.Values
	if r.Method == "GET" {
		queryParams = r.URL.Query()
	} else {
		err := r.ParseForm()
		if err != nil {
			http.Error(w, "{\"error\": \""+err.Error()+"\"}", http.StatusBadRequest)
			return
		}
		queryParams = r.Form
	}

	params.Login = queryParams.Get("login")

	if params.Login == "" {
		http.Error(w, "{\"error\": \"login must be not empty\"}", http.StatusBadRequest)
		return
	}

	if len(params.Login) < 10 {
		http.Error(w, "{\"error\": \"login len must be >= 10\"}", http.StatusBadRequest)
		return
	}

	params.Name = queryParams.Get("full_name")

	params.Status = queryParams.Get("status")

	validValues := []string{"user", "moderator", "admin"}
	isValid := false
	for _, v := range validValues {
		if params.Status == v {
			isValid = true
			break
		}
	}
	if !isValid && params.Status != "" {
		http.Error(w, "{\"error\": \"status must be one of ["+strings.Join(validValues, ", ")+"]\"}", http.StatusBadRequest)
		return
	}

	if params.Status == "" {
		params.Status = "user"
	}

	AgeStr := queryParams.Get("age")
	if AgeStr != "" {
		AgeVal, err := strconv.Atoi(AgeStr)
		if err != nil {
			http.Error(w, "{\"error\": \"age must be int\"}", http.StatusBadRequest)
			return
		}

		if AgeVal < 0 {
			http.Error(w, "{\"error\": \"age must be >= 0\"}", http.StatusBadRequest)
			return
		}

		if AgeVal > 128 {
			http.Error(w, "{\"error\": \"age must be <= 128\"}", http.StatusBadRequest)
			return
		}

		params.Age = AgeVal
	}

	res, err := h.Create(r.Context(), params)
	if err != nil {
		if apiErr, ok := err.(ApiError); ok {
			http.Error(w, "{\"error\": \""+apiErr.Error()+"\"}", apiErr.HTTPStatus)
		} else {
			http.Error(w, "{\"error\": \""+err.Error()+"\"}", http.StatusInternalServerError)
		}
		return
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"error":    "",
		"response": res,
	})
}

func (h *MyApi) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	switch r.URL.Path {

	case "/user/profile":
		h.handlerProfile(w, r)

	case "/user/create":
		h.handlerCreate(w, r)

	default:
		http.Error(w, "{\"error\": \"unknown method\"}", http.StatusNotFound)
	}
}

func (h *OtherApi) handlerCreate(w http.ResponseWriter, r *http.Request) {

	authKey := os.Getenv("OTHER_API_KEY")
	if authKey == "" {
		http.Error(w, "{\"error\": \"Server configuration error: missing auth key\"}", http.StatusInternalServerError)
		return
	}
	if r.Header.Get("X-Auth") != authKey {
		http.Error(w, "{\"error\": \"unauthorized\"}", http.StatusForbidden)
		return
	}

	allowedMethods := strings.Split("POST", ",")
	methodAllowed := false
	for _, m := range allowedMethods {
		if r.Method == strings.TrimSpace(m) {
			methodAllowed = true
			break
		}
	}
	if !methodAllowed {
		http.Error(w, "{\"error\": \"bad method\"}", http.StatusNotAcceptable)
		return
	}

	var params OtherCreateParams

	var queryParams url.Values
	if r.Method == "GET" {
		queryParams = r.URL.Query()
	} else {
		err := r.ParseForm()
		if err != nil {
			http.Error(w, "{\"error\": \""+err.Error()+"\"}", http.StatusBadRequest)
			return
		}
		queryParams = r.Form
	}

	params.Username = queryParams.Get("username")

	if params.Username == "" {
		http.Error(w, "{\"error\": \"username must be not empty\"}", http.StatusBadRequest)
		return
	}

	if len(params.Username) < 3 {
		http.Error(w, "{\"error\": \"username len must be >= 3\"}", http.StatusBadRequest)
		return
	}

	params.Name = queryParams.Get("account_name")

	params.Class = queryParams.Get("class")

	validValues := []string{"warrior", "sorcerer", "rouge"}
	isValid := false
	for _, v := range validValues {
		if params.Class == v {
			isValid = true
			break
		}
	}
	if !isValid && params.Class != "" {
		http.Error(w, "{\"error\": \"class must be one of ["+strings.Join(validValues, ", ")+"]\"}", http.StatusBadRequest)
		return
	}

	if params.Class == "" {
		params.Class = "warrior"
	}

	LevelStr := queryParams.Get("level")
	if LevelStr != "" {
		LevelVal, err := strconv.Atoi(LevelStr)
		if err != nil {
			http.Error(w, "{\"error\": \"level must be int\"}", http.StatusBadRequest)
			return
		}

		if LevelVal < 1 {
			http.Error(w, "{\"error\": \"level must be >= 1\"}", http.StatusBadRequest)
			return
		}

		if LevelVal > 50 {
			http.Error(w, "{\"error\": \"level must be <= 50\"}", http.StatusBadRequest)
			return
		}

		params.Level = LevelVal
	}

	res, err := h.Create(r.Context(), params)
	if err != nil {
		if apiErr, ok := err.(ApiError); ok {
			http.Error(w, "{\"error\": \""+apiErr.Error()+"\"}", apiErr.HTTPStatus)
		} else {
			http.Error(w, "{\"error\": \""+err.Error()+"\"}", http.StatusInternalServerError)
		}
		return
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"error":    "",
		"response": res,
	})
}

func (h *OtherApi) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	switch r.URL.Path {

	case "/user/create":
		h.handlerCreate(w, r)

	default:
		http.Error(w, "{\"error\": \"unknown method\"}", http.StatusNotFound)
	}
}
