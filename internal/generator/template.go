package generator

import (
	"strings"
	"text/template"
)

var funcMap = template.FuncMap{
	"toLower": strings.ToLower,
	"join":    strings.Join,
}

var handlerTemplate = template.Must(template.New("handler").Funcs(funcMap).Parse(`
// Code generated by gonerator. DO NOT EDIT.

package {{.PackageName}}

import (
    "encoding/json"
    "net/http"
    "net/url"
    "os"
    "strconv"
    "strings"
)

{{range $receiverType, $methods := .Methods}}
{{range $methods}}
func (h *{{$receiverType}}) handler{{.Name}}(w http.ResponseWriter, r *http.Request) {
    {{if .ApiMethod.Auth}}
    authKey := os.Getenv("{{.ApiMethod.AuthEnvKey}}")
    if authKey == "" {
        http.Error(w, "{\"error\": \"Server configuration error: missing auth key\"}", http.StatusInternalServerError)
        return
    }
    if r.Header.Get("X-Auth") != authKey {
        http.Error(w, "{\"error\": \"unauthorized\"}", http.StatusForbidden)
        return
    }
    {{end}}

    allowedMethods := strings.Split("{{.ApiMethod.Method}}", ",")
    methodAllowed := false
    for _, m := range allowedMethods {
        if r.Method == strings.TrimSpace(m) {
            methodAllowed = true
            break
        }
    }
    if !methodAllowed {
        http.Error(w, "{\"error\": \"bad method\"}", http.StatusNotAcceptable)
        return
    }

    var params {{.InputType}}

    var queryParams url.Values
    if r.Method == "GET" {
        queryParams = r.URL.Query()
    } else {
        err := r.ParseForm()
        if err != nil {
            http.Error(w, "{\"error\": \"" + err.Error() + "\"}", http.StatusBadRequest)
            return
        }
        queryParams = r.Form
    }

    {{range .StructFields}}
    {{if eq .Type "int"}}
    {{.Name}}Str := queryParams.Get("{{if .Tag.ParamName}}{{.Tag.ParamName}}{{else}}{{toLower .Name}}{{end}}")
    if {{.Name}}Str != "" {
        {{.Name}}Val, err := strconv.Atoi({{.Name}}Str)
        if err != nil {
            http.Error(w, "{\"error\": \"{{toLower .Name}} must be int\"}", http.StatusBadRequest)
            return
        }
        {{if .Tag.Min}}
        if {{.Name}}Val < {{.Tag.Min}} {
            http.Error(w, "{\"error\": \"{{toLower .Name}} must be >= {{.Tag.Min}}\"}", http.StatusBadRequest)
            return
        }
        {{end}}
        {{if .Tag.Max}}
        if {{.Name}}Val > {{.Tag.Max}} {
            http.Error(w, "{\"error\": \"{{toLower .Name}} must be <= {{.Tag.Max}}\"}", http.StatusBadRequest)
            return
        }
        {{end}}
        params.{{.Name}} = {{.Name}}Val
    }
    {{else}}
    params.{{.Name}} = queryParams.Get("{{if .Tag.ParamName}}{{.Tag.ParamName}}{{else}}{{toLower .Name}}{{end}}")
    {{if .Tag.Required}}
    if params.{{.Name}} == "" {
        http.Error(w, "{\"error\": \"{{toLower .Name}} must be not empty\"}", http.StatusBadRequest)
        return
    }
    {{end}}
    {{if .Tag.Min}}
    if len(params.{{.Name}}) < {{.Tag.Min}} {
        http.Error(w, "{\"error\": \"{{toLower .Name}} len must be >= {{.Tag.Min}}\"}", http.StatusBadRequest)
        return
    }
    {{end}}
    {{if .Tag.Max}}
    if len(params.{{.Name}}) > {{.Tag.Max}} {
        http.Error(w, "{\"error\": \"{{toLower .Name}} len must be <= {{.Tag.Max}}\"}", http.StatusBadRequest)
        return
    }
    {{end}}
    {{if .Tag.Enum}}
    validValues := []string{ {{range .Tag.Enum}}"{{.}}", {{end}} }
    isValid := false
    for _, v := range validValues {
        if params.{{.Name}} == v {
            isValid = true
            break
        }
    }
    if !isValid && params.{{.Name}} != "" {
        http.Error(w, "{\"error\": \"{{toLower .Name}} must be one of [" + strings.Join(validValues, ", ") + "]\"}", http.StatusBadRequest)
        return
    }
    {{end}}
    {{if .Tag.Default}}
    if params.{{.Name}} == "" {
        params.{{.Name}} = "{{.Tag.Default}}"
    }
    {{end}}
    {{end}}
    {{end}}

    res, err := h.{{.Name}}(r.Context(), params)
    if err != nil {
        if apiErr, ok := err.(ApiError); ok {
            http.Error(w, "{\"error\": \"" + apiErr.Error() + "\"}", apiErr.HTTPStatus)
        } else {
            http.Error(w, "{\"error\": \"" + err.Error() + "\"}", http.StatusInternalServerError)
        }
        return
    }

    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(map[string]interface{}{
        "error":    "",
        "response": res,
    })
}
{{end}}

func (h *{{$receiverType}}) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    switch r.URL.Path {
    {{range $methods}}
    case "{{.ApiMethod.Url}}":
        h.handler{{.Name}}(w, r)
    {{end}}
    default:
        http.Error(w, "{\"error\": \"unknown method\"}", http.StatusNotFound)
    }
}
{{end}}
`))
